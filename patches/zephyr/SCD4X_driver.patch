From 89a8212b673fd2c27bb20c0335711d8323eda96e Mon Sep 17 00:00:00 2001
From: Stephen Oliver <steve@infincia.com>
Date: Wed, 1 Jun 2022 20:03:17 -0500
Subject: [PATCH] drivers/sensor: Add support for SCD4X

This adds support for the Sensirion SCD40/SCD41 CO2 sensor family.

I have tried to match the design of other similar drivers in Zephyr,
using the sensor subsystem for CO2, temperature and relative humidity
which are implemented as sensor channels.

I've also used the device tree for most of the sensor settings, as
the sensor would have to be put back to idle mode to change most of
them at runtime, and they aren't things you would want to change
often anyway.

The ambient pressure setting can be changed at any time if another
sensor is connected that provides a pressure measurement, so that one
has a public API function for user code. The sensor uses the ambient
pressure level calculation internally to increase CO2 measurement
accuracy.

The compile time settings are:

* The model within the SCD4X family (SCD40, SCD41)
* The measurement mode (periodic, low power periodic, single-shot)
* Autocalibration
* Temperature offset for the temperature/humidity measurements
* Altitude

The device tree binding has more details on how to use them.

The driver is currently not enforcing invalid combinations of
settings at compile time, instead it will configure the sensor in a
way that will still work. This may need to change, however I'm not
sure of the best way to do it, perhaps using DT macros?

For example the SCD41 supports measurement modes that SCD40 doesn't,
such as the low power periodic and single-shot modes. Right now if
SCD40 is selected, the driver will ignore those other two modes even
if one is enabled.

There is one Kconfig option that puts the SCD41 to sleep after
single-shot measurements (between calls to sensor_sample_fetch()).

I'm open to suggestions on whether that's even a good idea, or whether
it should just be linked to CONFIG_PM instead (or both).

Signed-off-by: Stephen Oliver <steve@infincia.com>
---
 drivers/sensor/CMakeLists.txt            |   1 +
 drivers/sensor/Kconfig                   |   2 +
 drivers/sensor/scd4x/CMakeLists.txt      |   5 +
 drivers/sensor/scd4x/Kconfig             |  17 +
 drivers/sensor/scd4x/scd4x.c             | 586 +++++++++++++++++++++++
 drivers/sensor/scd4x/scd4x.h             | 116 +++++
 dts/bindings/sensor/sensirion,scd4x.yaml |  61 +++
 include/zephyr/drivers/sensor/scd4x.h    |  40 ++
 8 files changed, 828 insertions(+)
 create mode 100644 drivers/sensor/scd4x/CMakeLists.txt
 create mode 100644 drivers/sensor/scd4x/Kconfig
 create mode 100644 drivers/sensor/scd4x/scd4x.c
 create mode 100644 drivers/sensor/scd4x/scd4x.h
 create mode 100644 dts/bindings/sensor/sensirion,scd4x.yaml
 create mode 100644 include/zephyr/drivers/sensor/scd4x.h

diff --git a/drivers/sensor/CMakeLists.txt b/drivers/sensor/CMakeLists.txt
index d7990f0cad1b..de97da934e9e 100644
--- a/drivers/sensor/CMakeLists.txt
+++ b/drivers/sensor/CMakeLists.txt
@@ -82,6 +82,7 @@ add_subdirectory_ifdef(CONFIG_SGP40		sgp40)
 add_subdirectory_ifdef(CONFIG_SHTCX		shtcx)
 add_subdirectory_ifdef(CONFIG_SHT3XD		sht3xd)
 add_subdirectory_ifdef(CONFIG_SHT4X		sht4x)
+add_subdirectory_ifdef(CONFIG_SCD4X			scd4x)
 add_subdirectory_ifdef(CONFIG_SI7006		si7006)
 add_subdirectory_ifdef(CONFIG_SI7055		si7055)
 add_subdirectory_ifdef(CONFIG_SI7060		si7060)
diff --git a/drivers/sensor/Kconfig b/drivers/sensor/Kconfig
index ee05ce7ffce4..2212775dfb14 100644
--- a/drivers/sensor/Kconfig
+++ b/drivers/sensor/Kconfig
@@ -204,6 +204,8 @@ source "drivers/sensor/sht3xd/Kconfig"
 
 source "drivers/sensor/sht4x/Kconfig"
 
+source "drivers/sensor/scd4x/Kconfig"
+
 source "drivers/sensor/si7006/Kconfig"
 
 source "drivers/sensor/si7055/Kconfig"
diff --git a/drivers/sensor/scd4x/CMakeLists.txt b/drivers/sensor/scd4x/CMakeLists.txt
new file mode 100644
index 000000000000..69f348fc202f
--- /dev/null
+++ b/drivers/sensor/scd4x/CMakeLists.txt
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: Apache-2.0
+
+zephyr_library()
+
+zephyr_library_sources(scd4x.c)
diff --git a/drivers/sensor/scd4x/Kconfig b/drivers/sensor/scd4x/Kconfig
new file mode 100644
index 000000000000..51e194fd3f38
--- /dev/null
+++ b/drivers/sensor/scd4x/Kconfig
@@ -0,0 +1,17 @@
+# SCD4x co2, temperature, and humidity sensor configuration options
+
+# Copyright (c) 2022 Stephen Oliver
+# SPDX-License-Identifier: Apache-2.0
+
+config SCD4X
+	bool "SCD4x CO2/Temperature/Humidity Sensor"
+	depends on I2C
+	help
+	  Enable driver for SCD4x co2, temperature, and humidity sensors.
+
+config SCD4X_POWER_DOWN_SINGLE_SHOT_MEASUREMENT
+	bool "SCD41 only: power down sensor between single-shot measurements"
+	depends on SCD4X
+	help
+	  Will send the power_down command to the sensor after a measurement, and wake it up again
+	  before the next measurement. Only works on SCD41 model.
diff --git a/drivers/sensor/scd4x/scd4x.c b/drivers/sensor/scd4x/scd4x.c
new file mode 100644
index 000000000000..365bd5f33a5a
--- /dev/null
+++ b/drivers/sensor/scd4x/scd4x.c
@@ -0,0 +1,586 @@
+/*
+ * Copyright (c) 2022 Stephen Oliver
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */   
+
+#define DT_DRV_COMPAT sensirion_scd4x
+
+#include <stdio.h>
+
+#include <zephyr/device.h>
+#include <zephyr/drivers/i2c.h>
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/sensor.h>
+#include <zephyr/sys/__assert.h>
+#include <zephyr/logging/log.h>
+#include <zephyr/pm/device.h>
+#include <zephyr/sys/byteorder.h>
+#include <zephyr/sys/crc.h>
+
+#include <zephyr/drivers/sensor/scd4x.h>
+#include "scd4x.h"
+
+LOG_MODULE_REGISTER(SCD4X, CONFIG_SENSOR_LOG_LEVEL);
+
+
+static uint8_t scd4x_compute_crc(uint16_t value)
+{
+
+	uint8_t buf[2];
+
+	sys_put_be16(value, buf);
+
+	return crc8(buf, 2, SCD4X_CRC_POLY, SCD4X_CRC_INIT, false);
+}
+
+
+static int scd4x_write_command(const struct device *dev, uint16_t cmd)
+{
+	const struct scd4x_config *cfg = dev->config;
+	uint8_t tx_buf[2];
+
+	sys_put_be16(cmd, tx_buf);
+
+	return i2c_write_dt(&cfg->bus, tx_buf, sizeof(tx_buf));
+}
+
+
+static int scd4x_read_reg(const struct device *dev, uint16_t reg_addr, uint8_t *rx_buf, uint8_t rx_buf_size)
+{
+	const struct scd4x_config *cfg = dev->config;
+	int rc;
+
+	rc = scd4x_write_command(dev, reg_addr);
+
+	k_sleep(K_USEC(1));
+
+	rc = i2c_read_dt(&cfg->bus, rx_buf, rx_buf_size);
+
+	return rc;
+}
+
+
+static int scd4x_write_reg(const struct device *dev, uint16_t cmd, uint16_t val)
+{
+	const struct scd4x_config *cfg = dev->config;
+	uint8_t tx_buf[5];
+
+	sys_put_be16(cmd, tx_buf);
+	sys_put_be16(val, &tx_buf[2]);
+	tx_buf[4] = scd4x_compute_crc(val);
+
+	return i2c_write_dt(&cfg->bus, tx_buf, sizeof(tx_buf));
+}
+
+#if defined(SCD4X_POWER_DOWN_SINGLE_SHOT_MEASUREMENT) || defined(CONFIG_PM_DEVICE) 
+static int scd4x_power_down(const struct device *dev)
+{
+	int rc;
+
+	rc = scd4x_write_command(dev, SCD4X_CMD_POWER_DOWN);
+	k_sleep(K_MSEC(SCD4X_POWER_DOWN_WAIT_MS));
+
+	return rc;
+}
+#endif
+
+
+static void scd4x_wake_up(const struct device *dev)
+{
+	/*
+	 * The sensor does not respond to this command, regardless of whether it was successfully
+	 * received and executed or not. As a result, any error that occurs here is not detectable.
+	 */
+	scd4x_write_command(dev, SCD4X_CMD_WAKE_UP);
+	k_sleep(K_MSEC(SCD4X_WAKE_UP_WAIT_MS));
+}
+
+
+static int scd4x_stop_periodic_measurement(const struct device *dev)
+{
+	int rc;
+
+	rc = scd4x_write_command(dev, SCD4X_CMD_STOP_PERIODIC_MEASUREMENT);
+	k_sleep(K_MSEC(SCD4X_STOP_PERIODIC_MEASUREMENT_WAIT_MS));
+	
+	return rc;
+}
+
+
+static int scd4x_reinit(const struct device *dev)
+{
+	int rc;
+
+	rc = scd4x_write_command(dev, SCD4X_CMD_REINIT);
+	k_sleep(K_MSEC(SCD4X_REINIT_WAIT_MS));
+
+	return rc;
+}
+
+
+static int scd4x_set_temperature_offset(const struct device *dev, uint16_t offset)
+{
+	int rc;
+
+	/* Datasheet 1.2, section 3.6.1: set_temperature_offset expects converted value */
+	uint16_t offset_raw = (uint16_t)(((offset * 65535U) + 87U) / 175U);
+
+	rc = scd4x_write_reg(dev, SCD4X_CMD_SET_TEMPERATURE_OFFSET, offset_raw);
+	k_sleep(K_MSEC(SCD4X_SET_TEMPERATURE_OFFSET_WAIT_MS));
+
+	return rc;
+}
+
+
+static int scd4x_get_temperature_offset(const struct device *dev, uint16_t *offset)
+{
+	int rc;
+
+	uint8_t rx_buf[3];
+
+	rc = scd4x_read_reg(dev, SCD4X_CMD_GET_TEMPERATURE_OFFSET, rx_buf, sizeof(rx_buf));
+	k_sleep(K_MSEC(SCD4X_GET_TEMPERATURE_OFFSET_WAIT_MS));
+
+	/* Datasheet 1.2, section 3.6.2: get_temperature_offset provides conversion formula */
+	uint16_t offset_raw = sys_get_be16(&rx_buf[0]);
+
+	if (scd4x_compute_crc(offset_raw) != rx_buf[2]) {
+		LOG_ERR("Invalid CRC for temperature offset.");
+		return -EIO;
+	}
+
+	*offset = (uint16_t)((offset_raw * 175U) / 65535U);
+
+	return rc;
+}
+
+
+static int scd4x_set_sensor_altitude(const struct device *dev, uint16_t altitude)
+{
+	int rc;
+
+	rc = scd4x_write_reg(dev, SCD4X_CMD_SET_SENSOR_ALTITUDE, altitude);
+	k_sleep(K_MSEC(SCD4X_SET_SENSOR_ALTITUDE_WAIT_MS));
+
+	return rc;
+}
+
+
+static int scd4x_get_sensor_altitude(const struct device *dev, uint16_t *altitude)
+{
+	int rc;
+	uint8_t rx_buf[3];
+
+	rc = scd4x_read_reg(dev, SCD4X_CMD_GET_SENSOR_ALTITUDE, rx_buf, sizeof(rx_buf));
+	k_sleep(K_MSEC(SCD4X_GET_SENSOR_ALTITUDE_WAIT_MS));
+
+	*altitude = sys_get_be16(&rx_buf[0]);
+
+	if (scd4x_compute_crc(*altitude) != rx_buf[2]) {
+		LOG_ERR("Invalid CRC for sensor altitude.");
+		return -EIO;
+	}
+
+	return rc;
+}
+
+
+int scd4x_set_ambient_pressure(const struct device *dev, uint16_t pressure)
+{	
+	int rc;
+
+	/* Datasheet 1.2, section 3.4: set_sensor_altitude expects altitude value divided by 100, add
+	 * 50 first to correct for rounding errors
+	 */
+	uint16_t raw_value = (pressure + 50U) / 100U;
+	rc = scd4x_write_reg(dev, SCD4X_CMD_SET_AMBIENT_PRESSURE, raw_value);
+	
+	k_sleep(K_MSEC(SCD4X_SET_AMBIENT_PRESSURE_WAIT_MS));
+
+	return rc;
+}
+
+
+static int scd4x_start_periodic_measurement(const struct device *dev, enum scd4x_measure_mode measure_mode) {
+	int cmd;
+
+	if (measure_mode == MEASURE_MODE_LOW_POWER) {
+		cmd = SCD4X_CMD_START_LOW_POWER_PERIODIC_MEASUREMENT;
+	} else if (measure_mode == MEASURE_MODE_NORMAL) {
+		cmd = SCD4X_CMD_START_PERIODIC_MEASUREMENT;
+	}
+
+	return scd4x_write_command(dev, cmd);
+}
+
+
+/*
+ * Retrieve the sensor serial number and stores it in the scd4x_data struct for debugging or future use
+ */
+static int scd4x_get_serial_number(const struct device *dev)
+{
+	const struct scd4x_config *cfg = dev->config;
+	struct scd4x_data *data = dev->data;
+	int rc;
+
+	uint8_t rx_buf[15];
+
+	rc = scd4x_read_reg(dev, SCD4X_CMD_GET_SERIAL_NUMBER, rx_buf, sizeof(rx_buf));
+	if (rc < 0) {
+		LOG_ERR("Failed to read data from device. (%d)", rc);
+		return rc;
+	}
+
+	k_sleep(K_MSEC(1));
+
+	uint16_t serial_number0 = sys_get_be16(&rx_buf[0]);
+	if (scd4x_compute_crc(serial_number0) != rx_buf[2]) {
+		LOG_ERR("Invalid CRC0 for serial number.");
+		return -EIO;
+	}
+
+	uint16_t serial_number1 = sys_get_be16(&rx_buf[3]);
+	if (scd4x_compute_crc(serial_number1) != rx_buf[5]) {
+		LOG_ERR("Invalid CRC1 for serial number.");
+		return -EIO;
+	}
+
+	uint16_t serial_number2 = sys_get_be16(&rx_buf[6]);
+	if (scd4x_compute_crc(serial_number2) != rx_buf[8]) {
+		LOG_ERR("Invalid CRC2 for serial number.");
+		return -EIO;
+	}
+
+	snprintf(data->serial_number, sizeof(data->serial_number), "0x%04x%04x%04x", serial_number0, serial_number1, serial_number2);
+
+	return rc;
+}
+
+
+/*
+ * Process the measurement returned from the sensor. Response is a 9 byte buffer containing 3 sensor values.
+ * 
+ * Sensor measurement values are 2 bytes long, and each one is followed by a 1 byte CRC calculated by the
+ * sensor.
+ * 
+ * On SCD41 in single shot measurement mode, if only the temperature and humidity channels have been requested
+ * by the user, the sensor will still produce a CO2 value but it will always be 0 ppm.
+ */ 
+static int scd4x_read_sample(const struct device *dev,
+		uint16_t *t_sample,
+		uint16_t *rh_sample,
+		uint16_t *co2_sample)
+{
+
+	const struct scd4x_config *cfg = dev->config;
+	uint8_t rx_buf[9];
+	int rc;
+
+	rc = i2c_read_dt(&cfg->bus, rx_buf, sizeof(rx_buf));
+	if (rc < 0) {
+		LOG_ERR("Failed to read data from device.");
+		return rc;
+	}
+
+	*co2_sample = sys_get_be16(rx_buf);
+	if (scd4x_compute_crc(*co2_sample) != rx_buf[2]) {
+		LOG_ERR("Invalid CRC for CO2.");
+		return -EIO;
+	}
+
+	*t_sample = sys_get_be16(&rx_buf[3]);
+	if (scd4x_compute_crc(*t_sample) != rx_buf[5]) {
+		LOG_ERR("Invalid CRC for T.");
+		return -EIO;
+	}
+
+	*rh_sample = sys_get_be16(&rx_buf[6]);
+	if (scd4x_compute_crc(*rh_sample) != rx_buf[8]) {
+		LOG_ERR("Invalid CRC for RH.");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static int scd4x_sample_fetch(const struct device *dev,
+							  enum sensor_channel chan)
+{
+	const struct scd4x_config *cfg = dev->config;
+	struct scd4x_data *data = dev->data;
+	int rc;
+
+	if (chan != SENSOR_CHAN_ALL &&
+		chan != SENSOR_CHAN_AMBIENT_TEMP &&
+		chan != SENSOR_CHAN_HUMIDITY &&
+		chan != SENSOR_CHAN_CO2) {
+		return -ENOTSUP;
+	}
+	/*
+	 * SCD41 in single shot measure mode. The requested sensor channels determine which command is sent
+	 * because the wait time is different by a factor of 100. The full measurement takes 5000ms while
+	 * the temperature/humidity only command takes 50ms.
+	 */
+	if (cfg->model == SCD41 && cfg->measure_mode == MEASURE_MODE_SINGLE_SHOT) {
+		#if defined(SCD4X_POWER_DOWN_SINGLE_SHOT_MEASUREMENT)
+		/*
+		 * Wake up the sensor if necessary before issuing a single shot command, will be powered
+		 * down again after reading the measurement.
+		 */
+		scd4x_wake_up(dev);
+		#endif
+
+		if ((chan & SENSOR_CHAN_AMBIENT_TEMP) ||
+			(chan & SENSOR_CHAN_HUMIDITY)) {
+			rc = scd4x_write_command(dev, SCD4X_CMD_MEASURE_SINGLE_SHOT_RHT_ONLY);
+			if (rc < 0 && cfg->model == SCD41) {
+				LOG_ERR("Failed to send single shot measure command");
+				return rc;
+			}
+			k_sleep(K_MSEC(SCD4X_MEASURE_SINGLE_SHOT_RHT_ONLY_WAIT_MS));
+		} else {
+			rc = scd4x_write_command(dev, SCD4X_CMD_MEASURE_SINGLE_SHOT);
+			if (rc < 0 && cfg->model == SCD41) {
+				LOG_ERR("Failed to send single shot measure command");
+				return rc;
+			}
+			k_sleep(K_MSEC(SCD4X_MEASURE_SINGLE_SHOT_WAIT_MS));
+		}
+	} else {
+		/*
+		 * Poll the data ready flag before attempting to read the measurement, otherwise the sensor
+		 * will respond with a NACK. 
+		 * 
+		 * It is assumed that if the sensor has lost power or is otherwise not responding, then scd4x_read_reg
+		 * will return an error, which should prevent the kernel from getting stuck in an infinite loop here.
+		 */
+		uint16_t status_register;
+		while (!(SCD4X_MEASURE_READY(status_register))) {
+			uint8_t rx_buf[3];
+			rc = scd4x_read_reg(dev, SCD4X_CMD_GET_DATA_READY_STATUS, rx_buf, sizeof(rx_buf));
+			if (rc) {
+				LOG_ERR("Failed to read device status.");
+				return rc;
+			}
+
+			status_register = sys_get_be16(&rx_buf[0]);
+
+			if (scd4x_compute_crc(status_register) != rx_buf[2]) {
+				LOG_ERR("Invalid CRC for data ready flag.");
+				return -EIO;
+			}
+
+			/*
+			 * It could be up to 5000ms before the sensor measurement is ready, checking more often
+			 * than this could interfere with other I2C devices on the bus.
+			 */
+			k_sleep(K_USEC(500));
+		}
+	}
+
+	/*
+	 * Measurement is read from the sensor the same way regardless of which mode is in use.
+	 */
+	rc = scd4x_write_command(dev, SCD4X_CMD_READ_MEASUREMENT);
+	if (rc < 0) {
+		LOG_ERR("Failed to start measurement.");
+		return rc;
+	}
+	k_sleep(K_USEC(SCD4X_READ_MEASUREMENT_WAIT_MS));
+
+
+	rc = scd4x_read_sample(dev, &data->t_sample, &data->rh_sample, &data->co2_sample);
+	if (rc < 0) {
+		LOG_ERR("Failed to read measurement from device.");
+		return rc;
+	}
+
+	#if defined(SCD4X_POWER_DOWN_SINGLE_SHOT_MEASUREMENT)
+	if (cfg->model == SCD41 && cfg->measure_mode == MEASURE_MODE_SINGLE_SHOT) {
+		/* 
+		 * Put the sensor to sleep again until the next measurement
+		 */
+		scd4x_power_down(dev);
+	}
+	#endif
+
+	return 0;
+}
+
+static int scd4x_channel_get(const struct device *dev,
+							 enum sensor_channel chan,
+							 struct sensor_value *val)
+{
+
+	const struct scd4x_data *data = dev->data;
+
+	if (chan == SENSOR_CHAN_AMBIENT_TEMP) {
+		int64_t tmp;
+
+		tmp = data->t_sample * 175U;
+		val->val1 = (int32_t)(tmp / 0xFFFFU) - 45U;
+		val->val2 = ((tmp % 0xFFFFU) * 1000000U) / 0xFFFFU;
+	} else if (chan == SENSOR_CHAN_HUMIDITY) {
+		uint64_t tmp;
+
+		tmp = data->rh_sample * 100U;
+		val->val1 = tmp / 0x10000U;
+		val->val2 = (tmp % 0x10000U) * 15625U / 1024U;
+	} else if (chan == SENSOR_CHAN_CO2) {
+		val->val1 = data->co2_sample;
+		val->val2 = 0;
+	} else {
+		return -ENOTSUP;
+	}
+
+	return 0;
+}
+
+
+#if defined(CONFIG_PM_DEVICE)
+static int scd4x_pm_action(const struct device *dev, 
+						   enum pm_device_action action)
+{
+
+	const struct scd4x_config *cfg = dev->config;
+	int rc;
+	
+	switch (action) {
+	case PM_DEVICE_ACTION_RESUME:
+		scd4x_wake_up(dev);
+		rc = scd4x_start_periodic_measurement(dev, cfg->measure_mode);
+		break;
+	case PM_DEVICE_ACTION_SUSPEND:
+		rc = scd4x_stop_periodic_measurement(dev);
+		rc = scd4x_power_down(dev);
+		break;
+	default:
+		return -ENOTSUP;
+	}
+
+	return rc;
+}
+#endif /* CONFIG_PM_DEVICE */
+
+
+static int scd4x_init(const struct device *dev)
+{
+	const struct scd4x_config *cfg = dev->config;
+	struct scd4x_data *data = dev->data;
+	int rc = 0;
+
+	if (!device_is_ready(cfg->bus.bus)) {
+		LOG_ERR("Device not ready.");
+		return -ENODEV;
+	}
+
+	scd4x_wake_up(dev);
+
+	rc = scd4x_stop_periodic_measurement(dev);
+	if (rc < 0) {
+		LOG_ERR("Failed to stop periodic measurement on the device.");
+		return rc;
+	}
+
+	rc = scd4x_reinit(dev);
+	if (rc < 0) {
+		LOG_ERR("Failed to reinitialize the device.");
+		return rc;
+	}
+
+	rc = scd4x_set_sensor_altitude(dev, cfg->altitude);
+	if (rc < 0) {
+		LOG_ERR("Failed to set sensor altitude on the device.");
+		return rc;
+	}
+
+
+	uint16_t sensor_altitude;
+	rc = scd4x_get_sensor_altitude(dev, &sensor_altitude);
+	if (rc < 0) {
+		LOG_ERR("Failed to get sensor altitude from the device.");
+		return rc;
+	}
+
+
+	rc = scd4x_set_temperature_offset(dev, cfg->temperature_offset);
+	if (rc < 0) {
+		LOG_ERR("Failed to set temperature offset on the device.");
+		return rc;
+	}
+
+
+	int16_t temperature_offset;
+	rc = scd4x_get_temperature_offset(dev, &temperature_offset);
+	if (rc < 0) {
+		LOG_ERR("Failed to get temperature offset from the device.");
+		return rc;
+	}
+
+
+	rc = scd4x_get_serial_number(dev);
+	if (rc < 0) {
+		LOG_ERR("Failed to read serial number from the device.");
+		return rc;
+	}
+
+
+	rc = scd4x_write_reg(dev, SCD4X_CMD_SET_AUTOMATIC_SELF_CALIBRATION_ENABLED, cfg->auto_calibration);
+	if (rc < 0) {
+		LOG_ERR("Failed to set auto calibration on the device.");
+		return rc;
+	}
+	k_sleep(K_MSEC(SCD4X_SET_AUTOMATIC_CALIBRATION_WAIT_MS));
+
+	if (cfg->measure_mode == MEASURE_MODE_SINGLE_SHOT) {
+		#if defined(SCD4X_POWER_DOWN_SINGLE_SHOT_MEASUREMENT)
+		/*
+		 * Power down the sensor until the first measurement is requested
+		 */
+		scd4x_power_down(dev);
+		#endif
+	} else {
+		rc = scd4x_start_periodic_measurement(dev, cfg->measure_mode);
+		if (rc < 0) {
+			LOG_ERR("Failed to start periodic measurement on the device.");
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+
+static const struct sensor_driver_api scd4x_api = {
+	.sample_fetch = scd4x_sample_fetch,
+	.channel_get = scd4x_channel_get,
+};
+
+
+#define SCD4X_INIT(n)						\
+	static struct scd4x_data scd4x_data_##n;		\
+								\
+	static const struct scd4x_config scd4x_config_##n = {	\
+		.bus = I2C_DT_SPEC_INST_GET(n),			\
+		.model = DT_INST_ENUM_IDX(n, model),	\
+		.measure_mode = DT_INST_ENUM_IDX(n, measure_mode),	\
+		.auto_calibration = DT_INST_PROP(n, auto_calibration),	\
+		.temperature_offset = DT_INST_PROP(n, temperature_offset),	\
+		.altitude = DT_INST_PROP(n, altitude)	\
+	};							\
+								\
+	PM_DEVICE_DT_INST_DEFINE(n, scd4x_pm_action);		\
+								\
+	DEVICE_DT_INST_DEFINE(n,				\
+			      scd4x_init,			\
+			      NULL,				\
+			      &scd4x_data_##n,			\
+			      &scd4x_config_##n,		\
+			      POST_KERNEL,			\
+			      CONFIG_SENSOR_INIT_PRIORITY,	\
+			      &scd4x_api);
+
+DT_INST_FOREACH_STATUS_OKAY(SCD4X_INIT)
+
diff --git a/drivers/sensor/scd4x/scd4x.h b/drivers/sensor/scd4x/scd4x.h
new file mode 100644
index 000000000000..56ad74565bb9
--- /dev/null
+++ b/drivers/sensor/scd4x/scd4x.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2022 Stephen Oliver
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */   
+
+#ifndef ZEPHYR_DRIVERS_SENSOR_SCD4X_SCD4X_H_
+#define ZEPHYR_DRIVERS_SENSOR_SCD4X_SCD4X_H_
+
+#include <zephyr/device.h>
+
+
+#define SCD4X_MAX_AMBIENT_PRESSURE UINT16_MAX
+
+#define SCD4X_CMD_POWER_DOWN 	0x36E0
+#define SCD4X_CMD_WAKE_UP		0x36F6
+#define SCD4X_CMD_REINIT		0x3646
+
+#define SCD4X_CMD_START_PERIODIC_MEASUREMENT 			0x21B1
+#define SCD4X_CMD_STOP_PERIODIC_MEASUREMENT 			0x3F86
+#define SCD4X_CMD_START_LOW_POWER_PERIODIC_MEASUREMENT 	0x21AC
+
+#define SCD4X_CMD_GET_DATA_READY_STATUS 0xE4B8
+#define SCD4X_CMD_READ_MEASUREMENT 		0xEC05
+
+#define SCD4X_CMD_PERSIST_SETTINGS 	0x3615
+
+#define SCD4X_CMD_GET_SERIAL_NUMBER 0x3682
+
+#define SCD4X_CMD_PERFORM_SELF_TEST 0x3639
+#define SCD4X_CMD_PERFORM_FACTORY_RESET 0x3632
+
+#define SCD4X_CMD_SET_TEMPERATURE_OFFSET 0x241D
+#define SCD4X_CMD_GET_TEMPERATURE_OFFSET 0x2318
+
+#define SCD4X_CMD_SET_SENSOR_ALTITUDE 0x2427
+#define SCD4X_CMD_GET_SENSOR_ALTITUDE 0x2322
+
+#define SCD4X_CMD_SET_AMBIENT_PRESSURE 0xE000
+
+#define SCD4X_CMD_PERFORM_FORCED_RECALIBRATION 0x362F
+
+#define SCD4X_CMD_SET_AUTOMATIC_SELF_CALIBRATION_ENABLED 0x2416
+#define SCD4X_CMD_GET_AUTOMATIC_SELF_CALIBRATION_ENABLED 0x2313
+
+#define SCD4X_POWER_DOWN_WAIT_MS	1
+#define SCD4X_WAKE_UP_WAIT_MS	20
+#define SCD4X_REINIT_WAIT_MS	20
+#define SCD4X_PERFORM_SELF_TEST_WAIT_MS 10000
+#define SCD4X_PERFORM_FACTORY_RESET_WAIT_MS 1200
+#define SCD4X_STOP_PERIODIC_MEASUREMENT_WAIT_MS	500
+#define SCD4X_READ_MEASUREMENT_WAIT_MS	1
+#define SCD4X_SET_TEMPERATURE_OFFSET_WAIT_MS	1
+#define SCD4X_GET_TEMPERATURE_OFFSET_WAIT_MS	1
+#define SCD4X_SET_SENSOR_ALTITUDE_WAIT_MS	1
+#define SCD4X_GET_SENSOR_ALTITUDE_WAIT_MS	1
+#define SCD4X_SET_AMBIENT_PRESSURE_WAIT_MS	1
+#define SCD4X_SET_AUTOMATIC_CALIBRATION_WAIT_MS	1
+
+
+#define SCD4X_CMD_MEASURE_SINGLE_SHOT 0x219D
+#define SCD4X_CMD_MEASURE_SINGLE_SHOT_RHT_ONLY 0x2196
+
+#define SCD4X_MEASURE_SINGLE_SHOT_WAIT_MS 5000
+#define SCD4X_MEASURE_SINGLE_SHOT_RHT_ONLY_WAIT_MS 50
+
+/*
+* Used to mask SCD4X_CMD_GET_DATA_READY_STATUS response value.
+
+* The sensor datasheet does not document the meaning of each bit, nor does it state that any
+* particular bit will be set to 1 when data is ready, it only guarantees that the device is
+* NOT ready if these bits are all 0, and that any other value means data is ready.
+*/
+#define SCD4X_MEASURE_READY(x) (((x) & 0x07FF) != 0)
+
+/*
+ * CRC parameters from SCD4X datasheet version 1.2, section 3.11
+ */
+#define SCD4X_CRC_POLY		0x31
+#define SCD4X_CRC_INIT		0xFF
+
+/* defines matching the related enums DT_ENUM_IDX: */
+#define MODEL_SCD40	0
+#define MODEL_SCD41	1
+#define MEASURE_MODE_NORMAL			0
+#define MEASURE_MODE_LOW_POWER		1
+#define MEASURE_MODE_SINGLE_SHOT	2
+
+enum scd4x_model {
+	SCD40 = MODEL_SCD40,
+	SCD41 = MODEL_SCD41,
+};
+
+enum scd4x_measure_mode {
+	NORMAL = MEASURE_MODE_NORMAL,
+	LOW_POWER = MEASURE_MODE_LOW_POWER,
+	SINGLE_SHOT = MEASURE_MODE_SINGLE_SHOT,
+};
+
+struct scd4x_config {
+	struct i2c_dt_spec bus;
+	enum scd4x_model model;
+	enum scd4x_measure_mode measure_mode;
+	bool auto_calibration;
+	uint16_t temperature_offset;
+	uint16_t altitude;
+};
+
+struct scd4x_data {
+	uint16_t t_sample;
+	uint16_t rh_sample;
+	uint16_t co2_sample;
+	char serial_number[15];
+};
+
+#endif /* ZEPHYR_DRIVERS_SENSOR_SCD4X_SCD4X_H_ */
diff --git a/dts/bindings/sensor/sensirion,scd4x.yaml b/dts/bindings/sensor/sensirion,scd4x.yaml
new file mode 100644
index 000000000000..35108f17a5e5
--- /dev/null
+++ b/dts/bindings/sensor/sensirion,scd4x.yaml
@@ -0,0 +1,61 @@
+#
+# Copyright (c) 2022, Stephen Oliver
+#
+# SPDX-License-Identifier: Apache-2.0
+
+description: Sensirion SCD4x co2, humidity, and temperature sensor
+
+compatible: "sensirion,scd4x"
+
+include: i2c-device.yaml
+
+properties:
+  model:
+    type: string
+    required: true
+    description: |
+      The sensor model in use
+    enum:
+        - "scd40"
+        - "scd41"
+  measure-mode:
+    type: string
+    required: true
+    description: |
+      Normal: Background measurement produces a new sample every 5 seconds
+
+      Low power mode (SCD41 only): Similar to normal mode, sensor uses 3mA
+      rather than 13-18mA. Produces a new sample every 30 seconds.
+
+      Single-shot mode (SCD41 only): Similar to low-power mode but samples immediately
+      after sensor_sample_fetch() is called. See scd4x driver Kconfig options to
+      put sensor to sleep between samples.
+    enum:
+        - "normal"
+        - "low-power"
+        - "single-shot"
+  auto-calibration:
+    type: boolean
+    required: false
+    description: |
+       Recalibrates the sensor's 400ppm reference level to match lowest CO2 level seen in
+       past 7 days (assumed to be outdoor air). Disable if the sensor is never exposed to
+       outdoor air to avoid severe accuracy drift.
+  temperature-offset:
+    type: int
+    required: true
+    default: 4
+    description: |
+      Degrees centigrade. Sensor subtracts this from temperature before calculating
+      humidity. Does not affect CO2 sample. Use when sensor is inside a device that
+      is hotter than ambient temperature.
+  altitude:
+    type: int
+    required: false
+    default: 0
+    description: |
+      Meters above sea level, improves CO2 accuracy. Sensor uses it to calculate
+      ambient pressure.
+      
+      The scd4x_set_ambient_pressure() function in the driver can be called at any
+      time to update the sensor calculations, which will override the altitude setting.
diff --git a/include/zephyr/drivers/sensor/scd4x.h b/include/zephyr/drivers/sensor/scd4x.h
new file mode 100644
index 000000000000..2553f7a50bdb
--- /dev/null
+++ b/include/zephyr/drivers/sensor/scd4x.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2022, Stephen Oliver
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ * @brief API for Sensirion SCD4X CO2/T/RH sensors
+ *
+ * Only provides access to the sensor's pressure level setting, used for increasing CO2 accuracy.
+ */
+
+#ifndef ZEPHYR_INCLUDE_DRIVERS_SENSOR_SCD4X_H_
+#define ZEPHYR_INCLUDE_DRIVERS_SENSOR_SCD4X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <zephyr/drivers/sensor.h>
+
+
+/**
+ * @brief Updates the sensor ambient pressure value used for increasing CO2 accuracy. Overrides the altitude
+ *        set in the device tree. Can be set at any time.
+ *
+ * @param dev Pointer to the sensor device
+ * 
+ * @param pressure Ambient pressure, unit is Pascal
+ *
+ * @return 0 if successful, negative errno code if failure.
+ */
+int scd4x_set_ambient_pressure(const struct device *dev, uint16_t pressure);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_INCLUDE_DRIVERS_SENSOR_SCD4X_H_ */
